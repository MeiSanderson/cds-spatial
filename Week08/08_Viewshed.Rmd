---
title: "Viewsheds"
author: "Adela Sobotkova"
date: "2025-03-27"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Install from github
The goal of viewscape package is to provide an accessible method of carrying out landscape spatial analysis based on the viewshed within the R environment. The viewscape R package can currently be installed via github.
```{r viwescape}
# Install the package from CRAN
# install.packages("viewscape")
# 
# # Install the package from GitHub
# devtools::install_github("land-info-lab/viewscape", dependencies=TRUE)

# Load the package
library(viewscape)
library(terra)
library(sf)
```
## How it works
The basic viewshed analysis can be accessed through calling the `compute_viewshed`. The two needed objects are a digital surface model (DSM) and a viewpoint. It provides flexibility for single or multi-viewpoint analyses and allows options for parallel processing, raster output, and plotting. In addition, a `fov_mask` function is designed to subset a viewshed based on its viewpoint and the field of view.

Based on the viewshed, visual magnitude, a gradient of visibility across the range, can be calculated using the `visual_magnitude` function. Also, a set of configuration metrics can be calculated using `calculate_viewmetrics`, `calculate_diversity`, and `calculate_feature`.

```{r}
dsm <- terra::rast("../data/Aster.tif")
mounds <- read_sf("../data/KAZ_mounds.shp")
dsm <- dsm %>% crop(mounds)
plot(dsm)
viewpoint <- c(360001,4720001)
output <- viewscape::compute_viewshed(dsm = dsm, 
                                      viewpoints = viewpoint, 
                                      offset_viewpoint = 6, 
                                      r = 1600,
                                      method = 'plane')

```

```{r}
viewpoint <- vect(matrix(viewpoint, ncol = 2), type = "points", crs = "EPSG:32632")

# overlap viewshed on DSM
output_r <- viewscape::visualize_viewshed(output, outputtype = 'raster')
terra::plot(dsm, axes=TRUE, box=FALSE, legend = FALSE)
terra::plot(output_r, add=TRUE, col = "yellow", axes=FALSE, box=FALSE, legend = FALSE)
terra::plot(viewpoint, add = TRUE, col = "orange", axes=FALSE, box=FALSE, legend = FALSE)
```

## Subset viewshed using by specifying the field of view
```{r}
sector <- viewscape::fov_mask(output, c(90,260))
terra::plot(dsm, axes=FALSE, box=FALSE, legend = FALSE)
terra::plot(viewscape::visualize_viewshed(sector, outputtype = 'raster'),
            axes=FALSE, box=FALSE, legend = FALSE, add = TRUE, col = "yellow")
terra::plot(viewpoint, add = TRUE, col = "blue", axes=FALSE, box=FALSE, legend = FALSE)
```
## Compute visual magnitude
```{r}
vm <- viewscape::visual_magnitude(output,dsm)
terra::plot(vm, axes=FALSE, box=FALSE)
terra::plot(viewpoint, add = TRUE, col = "blue", axes=FALSE, box=FALSE, legend = FALSE)
```

## Compute the viewshed for multiple viewpoints

```{r}
# Load points (.shp file)
library(mapview)
mapview(mounds)
royal <- mounds %>% 
  dplyr::filter(TRAP_Code %in% c(1038, 1040, 3254, 3260))


# Compute viewsheds
output <- viewscape::compute_viewshed(dsm = dsm, 
                                      viewpoints = royal, 
                                      offset_viewpoint = 6, 
                                      parallel = TRUE, 
                                      workers = 1)
# Use plot all viewsheds on DSM
par(mfrow=c(3,3))
for(i in 1:length(output)) {
  each <- output[[i]]
  raster_data <- viewscape::visualize_viewshed(each, outputtype="raster")
  terra::plot(dsm, axes=FALSE, box=FALSE, legend = FALSE)
  terra::plot(raster_data, add=TRUE, col = "red", axes=FALSE, box=FALSE, legend = FALSE)
}

```

```{r}
# Convert each viewshed to a SpatRaster and store
viewsheds <- lapply(output, function(each) {
  viewscape::visualize_viewshed(each, outputtype = "raster")
})

(viewsheds)[[1]]

combined_vs <- viewsheds[[1]]
for (i in 2:length(viewsheds)) {
  combined_vs <- mosaic(combined_vs, viewsheds[[i]], fun = "sum")
}
plot(combined_vs)
ext(combined_vs)

# Optionally buffer a bit for nice margin (e.g., 100 meters)
ext_vs <- ext(combined_vs) + 350  # expand extent

# Crop the DSM
dsm_crop <- crop(dsm, ext_vs)

```

```{r}
# Plot
plot(dsm_crop, main = "Combined Viewsheds")
plot(combined_vs, col = "yellow", add = TRUE, legend = FALSE)
plot(royal$geometry, col = "red", pch = 24, cex = 1, add = T)

mapview(combined_vs) + mapview(royal)
```
## transparent viewsheds in own color
```{r}

colors <- adjustcolor(c("red", "blue", "green", "orange"), alpha.f = 0.4)

# Run the next bit together with the loop and points
plot(dsm_crop, col = rev(gray.colors(100)), main = "Multiple Viewsheds", axes = FALSE, box = FALSE)

# Loop through each viewshed and add to plot with unique transparent color
for (i in 1:4) {
  plot(viewsheds[[i]], 
       col = colors[i], 
       add = TRUE, 
       legend = FALSE)
}
point_colors <- c("red", "blue", "green", "orange")
points(royal, pch = 24, col = "white", bg = point_colors, cex = 2)


```

### refine the grayscale classes

```{r}
# Create breaks in 100 m intervals
breaks <- seq(floor(minmax(dsm_crop)[1]), ceiling(minmax(dsm_crop)[2]), by = 100)

# Classify the DSM into 100m bands
dsm_classes <- classify(dsm_crop, rcl = cbind(breaks[-length(breaks)], breaks[-1]))

n_classes <- length(unique(values(dsm_classes)))
plot(dsm_classes, 
     col = rev(gray.colors(n_classes)), 
     main = "Classified DSM (100m bands)", 
     axes = FALSE, box = FALSE, legend = TRUE)

```



## Shannon diversity index

```{r}
# Load DTM
test_dtm <- terra::rast(system.file("test_dtm.tif", 
                                    package ="viewscape"))

# load landuse raster
test_landuse <- terra::rast(system.file("test_landuse.tif",
                                        package ="viewscape"))

# Load canopy raster
test_canopy <- terra::rast(system.file("test_canopy.tif", 
                                       package ="viewscape"))

# Load building footprints raster
test_building <- terra::rast(system.file("test_building.tif", 
                                       package ="viewscape"))

# calculate metrics given the viewshed
test_metrics <- viewscape::calculate_viewmetrics(output, 
                                                 dsm, 
                                                 test_dtm, 
                                                 list(test_canopy, test_building))

# the Shannon Diversity Index (SDI)
test_diversity <- calculate_diversity(test_landuse, output, proportion = TRUE)
```

## Task: Apply viewsheds to shelters in Aarhus. Can they be easily seen in the urban fabric?

## Note
The package currently does not support multi-core processing on Windows system. The function `compute_viewshed` with `parallel = TRUE` will automatically work on single worker.

## References: 
https://rspatial.github.io/terra/reference/viewshed.html
https://land-info-lab.github.io/viewscape/

Franklin, W. R., & Ray, C. (1994, May). Higher isnâ€™t necessarily better: Visibility algorithms and experiments. In Advances in GIS research: sixth international symposium on spatial data handling (Vol. 2, pp. 751-770). Edinburgh: Taylor & Francis.

Wang, J., Robinson, G. J., & White, K. (2000). Generating viewsheds without using sightlines. Photogrammetric engineering and remote sensing, 66(1), 87-90.